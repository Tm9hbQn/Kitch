<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>The Strategic Heart Dossier: Kitsch Edition</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Quicksand:wght@400;600;700&display=swap" rel="stylesheet">

    <script src="https://cdn.tailwindcss.com"></script>

    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>

    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>

    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        body {
            font-family: 'Quicksand', sans-serif;
            background: linear-gradient(135deg, #FFC6D9 0%, #E0C3FC 100%);
            overflow-x: hidden;
            color: #6A0F49;
        }

        h1, h2, h3 {
            font-family: 'Pacifico', cursive;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.3);
        }
        ::-webkit-scrollbar-thumb {
            background: rgba(255, 51, 153, 0.5);
            border-radius: 10px;
        }

        .glass-card {
            background: rgba(255, 255, 255, 0.65);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 8px 32px 0 rgba(224, 195, 252, 0.37);
        }

        /* Floating Animation */
        @keyframes float {
            0% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(5deg); }
            100% { transform: translateY(0px) rotate(0deg); }
        }

        .floating-bg {
            animation: float 6s ease-in-out infinite;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- SAFEGUARD: Framer Motion fallback ---
        const MotionLib = window.Motion || {
            motion: {
                div: 'div', section: 'section', span: 'span', h1: 'h1', p: 'p', ellipse: 'ellipse', circle: 'circle', path: 'path', g: 'g'
            },
            AnimatePresence: ({children}) => children
        };
        const { motion, AnimatePresence } = MotionLib;

        // --- Configuration & Data ---

        // List A: Contextual Bubbles
        const CONTEXT_BUBBLES = [
            "◊ê◊™ ◊î◊ê◊°◊ú◊®◊ô◊™!", // 0
            "◊ó◊®◊ë ◊§◊ô◊§◊ô◊ï◊™ü§≠ü§≠ü§≠", // 1
            "◊ê◊ß◊°◊ô◊ï◊û◊î... ◊ñ◊î ◊©◊ù ◊©◊ú ◊û◊©◊ê◊ô◊™?", // 2
            "◊õ◊ê◊ë ◊§◊ô◊ñ◊ô ü¶π‚Äç‚ôÄÔ∏èüòàüî•", // 3
            "üê•üê•üê•üê•üê•üê•üê•üê•üê•üê•", // 4
            "üõ°Ô∏è‚öîÔ∏èü§¥ ◊ë◊ô ◊†◊©◊ë◊¢◊™◊ô ◊ú◊î◊í◊ü ◊¢◊ú◊ô◊ô◊ö ◊ì◊†◊ô◊ê◊ú◊î!", // 5
            "bitch wait ‚úãüõë", // 6
            "◊©◊ê◊û◊†◊ô◊ù ◊¢◊™◊ô◊ß◊ô◊ù... ◊ë◊ï◊ê◊ï ◊ê◊ú◊ô◊ô ◊ë◊®◊ï◊ó◊õ◊ù ‚ù§Ô∏èüôè" // 7
        ];

        // List B: Nagging Bubbles
        const NAG_BUBBLES = [
            "◊™◊ú◊ó◊¶◊ô ◊¢◊ú◊ô◊ô",
            "show me some love",
            "put it in",
            "squeesh me!"
        ];

        const contentData = [
            {
                id: "intro",
                title: "◊™◊ï◊®◊™ ◊î◊û◊©◊ó◊ß◊ô◊ù ◊ë◊û◊®◊ó◊ë ◊î◊°◊í◊ï◊®",
                cards: [
                    "◊ë◊ó◊ï◊•, ◊ê◊™ ◊û◊†◊î◊ú◊™ ◊ê◊ï◊§◊®◊¶◊ô◊ï◊™. ◊ô◊© ◊ú◊ö ◊ê◊™ ◊î◊ô◊õ◊ï◊ú◊™ ◊î◊†◊ì◊ô◊®◊î ◊ú◊®◊ê◊ï◊™ ◊ê◊™ ◊î◊û◊ê◊ß◊®◊ï, ◊ú◊ñ◊î◊ï◊™ ◊û◊í◊û◊ï◊™ ◊ú◊§◊†◊ô ◊©◊î◊ü ◊î◊ï◊§◊õ◊ï◊™ ◊ú◊õ◊ï◊™◊®◊ï◊™, ◊ú◊î◊ë◊ô◊ü ◊ê◊™ ◊î◊õ◊ï◊ó◊ï◊™ ◊©◊û◊†◊ô◊¢◊ô◊ù ◊î◊û◊ï◊†◊ô◊ù ◊ê◊ï ◊û◊†◊î◊ô◊í◊ô◊ù ◊†◊®◊ß◊ô◊°◊ô◊°◊ò◊ô◊ù. ◊ê◊™ ◊ó◊ì◊î, ◊ê◊™ ◊†◊ï◊õ◊ó◊™, ◊ï◊ê◊™ ◊ô◊ï◊ì◊¢◊™ ◊ë◊ì◊ô◊ï◊ß ◊ê◊ô◊ñ◊î ◊™◊ì◊® ◊ê◊™ ◊û◊©◊ì◊®◊™ ◊õ◊©◊ê◊™ ◊†◊õ◊†◊°◊™ ◊ú◊ó◊ì◊®. **◊î'◊î◊ê◊°◊ú' ◊ê◊¶◊ú◊ö ◊î◊ï◊ê ◊ú◊ê ◊î◊ô◊©◊®◊ì◊ï◊™, ◊î◊ï◊ê ◊ê◊û◊†◊ï◊™.**",
                    "◊ê◊ë◊ú ◊õ◊©◊ê◊™ ◊°◊ï◊í◊®◊™ ◊ê◊™ ◊î◊ì◊ú◊™, ◊ï◊î◊®◊¢◊© ◊©◊ú ◊î◊¢◊ï◊ú◊ù ‚Äì ◊î◊§◊ï◊ú◊ô◊ò◊ô◊ß◊î, ◊î◊ê◊ß◊ì◊û◊ô◊î, ◊î◊ò◊ô◊®◊ï◊£ ◊î◊ó◊ô◊¶◊ï◊†◊ô ‚Äì ◊†◊©◊ê◊® ◊ë◊ó◊ï◊•, ◊ê◊™ ◊†◊©◊ê◊®◊™ ◊¢◊ù ◊î◊©◊ß◊ò. ◊ï◊ë◊©◊ß◊ò ◊î◊ñ◊î, ◊ì◊ï◊ï◊ß◊ê **◊î◊ê◊ô◊†◊ò◊ú◊ô◊í◊†◊¶◊ô◊î ◊©◊ú◊ö ◊î◊ï◊§◊õ◊™ ◊ú◊ó◊®◊ë ◊§◊ô◊§◊ô◊ï◊™.**"
                ]
            },
            {
                id: "analysis",
                title: "◊î◊ì◊ô◊°◊ï◊†◊†◊° ◊î◊ê◊†◊ú◊ô◊ò◊ô",
                cards: [
                    "◊ô◊© ◊ê◊ô◊®◊ï◊†◊ô◊î ◊ê◊õ◊ñ◊®◊ô◊™ ◊ë◊õ◊ö ◊©◊ì◊ï◊ï◊ß◊ê ◊û◊ô ◊©◊û◊™◊û◊ó◊î ◊ë◊†◊ô◊™◊ï◊ó ◊û◊¢◊®◊õ◊ï◊™ ◊û◊ï◊®◊õ◊ë◊ï◊™, ◊û◊ï◊¶◊ê◊™ ◊ê◊™ ◊¢◊¶◊û◊î ◊ú◊ú◊ê ◊ê◊ú◊í◊ï◊®◊ô◊™◊ù ◊°◊ì◊ï◊® ◊û◊ï◊ú ◊î◊û◊¢◊®◊õ◊™ ◊î◊ñ◊ï◊í◊ô◊™ ◊î◊û◊ï◊°◊™◊®◊™ ◊î◊ñ◊ï. ◊î◊û◊ï◊ó ◊©◊ú◊ö, ◊©◊®◊í◊ô◊ú ◊ú◊§◊®◊ß ◊†◊®◊ò◊ô◊ë◊ô◊ù ◊ú◊ê◊ï◊û◊ô◊ô◊ù, ◊û◊†◊°◊î ◊ú◊î◊ó◊ô◊ú ◊ê◊™ ◊ê◊ï◊™◊î ◊ú◊ï◊í◊ô◊ß◊î ◊¢◊ú ◊©◊™◊ô◊ß◊ï◊™ ◊ï◊î◊ï◊ì◊¢◊ï◊™ ◊ò◊ß◊°◊ò.",
                    "◊ê◊™ ◊û◊†◊°◊î ◊ú◊û◊¶◊ï◊ê ◊ì◊§◊ï◊°◊ô◊ù ◊í◊ù ◊ë◊®◊¢◊© ◊ê◊ß◊®◊ê◊ô. ◊õ◊ú ◊î◊©◊î◊ô◊î, ◊õ◊ú ◊†◊ô◊ï◊ê◊†◊°, ◊†◊®◊©◊û◊ô◊ù ◊ê◊¶◊ú◊ö ◊õ◊û◊ï ◊®◊¢◊ô◊ì◊™ ◊ê◊ì◊û◊î. ◊î◊ë◊¢◊ô◊î ◊î◊ô◊ê ◊ú◊ê ◊©◊ê◊™ ◊ú◊ê ◊®◊ï◊ê◊î ◊ê◊™ ◊î◊û◊¶◊ô◊ê◊ï◊™, ◊ê◊ú◊ê ◊©◊ê◊™ ◊®◊ï◊ê◊î ◊ê◊ï◊™◊î ◊ë◊®◊ñ◊ï◊ú◊ï◊¶◊ô◊î ◊í◊ë◊ï◊î◊î ◊û◊ì◊ô. ◊î'◊ß◊ë◊ô◊¢◊ï◊™' ◊©◊ú ◊î◊ì◊ë◊®◊ô◊ù ◊û◊™◊¢◊®◊¢◊®◊™ ◊ê◊¶◊ú◊ö ◊ë◊®◊í◊¢ ◊©◊î◊ù ◊ô◊ï◊¶◊ê◊ô◊ù ◊û◊©◊ì◊î ◊î◊®◊ê◊ô◊ô◊î, ◊ï◊î◊¶◊ï◊®◊ö ◊ú◊ê◊©◊®◊® ◊ê◊™ ◊î◊ß◊ô◊ï◊ù ◊©◊ú ◊î◊ß◊©◊® ◊©◊ï◊ë ◊ï◊©◊ï◊ë ◊î◊ï◊ê ◊ú◊ê ◊ó◊ï◊ú◊©◊î ‚Äì ◊î◊ï◊ê **◊†◊ô◊°◊ô◊ï◊ü ◊ú◊ô◊ô◊¶◊® ◊ê◊ß◊°◊ô◊ï◊û◊î ◊ë◊™◊ï◊ö ◊û◊©◊ï◊ï◊ê◊î ◊©◊û◊©◊™◊†◊î ◊õ◊ú ◊î◊ñ◊û◊ü.**"
                ]
            },
            {
                id: "somatic_pain",
                title: "◊õ◊©◊î◊û◊ó◊©◊ë◊ï◊™ ◊î◊ï◊§◊õ◊ï◊™ ◊ú◊™◊ó◊ï◊©◊î ◊°◊ï◊û◊ò◊ô◊™",
                cards: [
                    "◊ú◊§◊¢◊û◊ô◊ù, ◊î◊û◊®◊ó◊ß ◊û◊ô◊ô◊¶◊® ◊®◊¢◊© ◊ú◊ë◊ü ◊©◊ê◊ô ◊ê◊§◊©◊® ◊ú◊î◊†◊û◊ô◊ö. ◊î◊û◊ó◊©◊ë◊ï◊™ ◊î◊ï◊§◊õ◊ï◊™ ◊°◊ï◊ê◊†◊ï◊™, ◊ï◊ñ◊î ◊õ◊ë◊® ◊ú◊ê ◊®◊ß ◊ë◊®◊ê◊© ‚Äì ◊ñ◊î ◊ë◊í◊ï◊£. ◊™◊ó◊ï◊©◊™ ◊î◊®◊ô◊ó◊ï◊ß ◊û◊™◊®◊í◊û◊™ ◊ê◊¶◊ú◊ö ◊ú**◊õ◊ê◊ë ◊§◊ô◊ñ◊ô ◊û◊û◊©**, ◊¶◊®◊ô◊ë◊î ◊õ◊û◊¢◊ò ◊¢◊ï◊®◊ô◊™ ◊©◊ú ◊ì◊ó◊ô◊ô◊î. ◊ê◊™ ◊û◊®◊í◊ô◊©◊î ◊ó◊©◊ï◊§◊î, ◊õ◊û◊¢◊ò ◊†◊ò◊ï◊ú◊™ ◊î◊í◊†◊ï◊™, ◊õ◊ê◊ô◊ú◊ï ◊û◊ô◊©◊î◊ï ◊õ◊ô◊ë◊î ◊ê◊™ ◊î◊ó◊ô◊û◊ï◊ù ◊ë◊ê◊û◊¶◊¢ ◊ô◊†◊ï◊ê◊®.",
                    "◊ï◊ê◊ñ ◊û◊í◊ô◊¢◊î ◊î◊ì◊ô◊ú◊û◊î ◊©◊ú ◊î◊û◊§◊í◊©. ◊î◊ê◊ô◊†◊°◊ò◊ô◊†◊ß◊ò ◊î◊ï◊ê ◊ú◊®◊ï◊• ◊ú◊©◊ù, ◊ú◊ß◊ë◊ú ◊ê◊™ ◊î◊™◊ô◊ß◊ï◊£ ◊©◊î◊õ◊ú ◊¢◊ì◊ô◊ô◊ü ◊ß◊ô◊ô◊ù. ◊ê◊ë◊ú ◊õ◊ê◊ü ◊†◊ì◊®◊© ◊û◊û◊ö ◊ï◊ô◊°◊ï◊™ ◊ê◊õ◊ñ◊®◊ô:",
                    "◊ú◊§◊†◊ô ◊©◊ê◊™ ◊ô◊ï◊¶◊ê◊™ ◊û◊î◊ë◊ô◊™, ◊™◊ë◊ì◊ß◊ô ◊ê◊™ ◊û◊ì◊ì ◊î◊û◊©◊ê◊ë◊ô◊ù. ◊î◊ê◊ù ◊î◊û◊§◊í◊© ◊î◊ñ◊î ◊ô◊î◊ô◊î ◊û◊°◊§◊ô◊ß? ◊î◊ê◊ù ◊ô◊© ◊ë◊ï ◊ê◊™ ◊î◊ñ◊û◊ü, ◊î◊¢◊ï◊û◊ß ◊ï◊î◊®◊ô◊õ◊ï◊ñ ◊©◊ê◊™ ‚Äì **◊î◊ê◊§◊®◊ï◊ó ◊î◊ß◊ò◊ü ◊©◊ë◊§◊†◊ô◊ù** ‚Äì ◊ó◊ô◊ô◊ë◊™ ◊õ◊®◊í◊¢?",
                    "◊î◊°◊õ◊†◊î ◊î◊í◊ì◊ï◊ú◊î ◊î◊ô◊ê ◊ú◊ê ◊ú◊ê ◊ú◊î◊ô◊§◊í◊©. ◊î◊°◊õ◊†◊î ◊î◊ô◊ê ◊ú◊î◊ô◊§◊í◊© ◊ú◊û◊¢◊ò ◊û◊ì◊ô. ◊ú◊¶◊ê◊™ ◊û◊û◊§◊í◊© ◊ò◊õ◊†◊ô ◊ê◊ï ◊ß◊¶◊® ◊õ◊©◊ê◊™ ◊ë◊¶◊û◊ê ◊®◊í◊©◊ô, ◊ñ◊î ◊û◊™◊õ◊ï◊ü ◊ú◊î◊™◊®◊°◊ß◊ï◊™. ◊ê◊™ ◊¢◊ú◊ï◊ú◊î ◊ú◊¶◊ê◊™ ◊û◊©◊ù ◊©◊ë◊ï◊®◊î ◊ô◊ï◊™◊®, ◊¢◊ù ◊™◊ó◊ï◊©◊™ ◊®◊ô◊ß◊†◊ï◊™ ◊©◊î◊ï◊õ◊§◊ú◊î. ◊î◊ó◊ï◊õ◊û◊î ◊î◊ô◊ê ◊ú◊ì◊¢◊™ ◊ú◊ï◊ï◊™◊® ◊¢◊ú ◊î◊§◊ô◊®◊ï◊®◊ô◊ù ◊õ◊ì◊ô **◊ú◊©◊û◊ï◊® ◊¢◊ú ◊î◊ú◊ë ◊©◊ú◊ö ◊©◊ú◊ù.** ◊ê◊ù ◊î◊°◊ô◊ò◊ï◊ê◊¶◊ô◊î ◊ú◊ê ◊û◊ê◊§◊©◊®◊™ ◊ú◊ï ◊ú◊¢◊ò◊ï◊£ ◊ê◊ï◊™◊ö ◊õ◊û◊ï ◊©◊ê◊™ ◊¶◊®◊ô◊õ◊î ◊î◊ô◊ï◊ù ‚Äì ◊¢◊ì◊ô◊£ ◊ú◊î◊ô◊©◊ê◊® ◊¢◊ù ◊î◊í◊¢◊í◊ï◊¢, ◊î◊ï◊ê ◊§◊ó◊ï◊™ ◊î◊®◊°◊†◊ô ◊û◊î◊ê◊õ◊ñ◊ë◊î."
                ]
            },
            {
                id: "cognitive_tax",
                title: "◊î◊û◊° ◊î◊ß◊ï◊í◊†◊ô◊ò◊ô◊ë◊ô",
                cards: [
                    "◊¢◊ë◊ï◊® ◊î◊¢◊ï◊ú◊ù ◊ê◊™ ◊õ◊ï◊ó ◊ò◊ë◊¢, ◊ê◊ë◊ú ◊î◊û◊†◊í◊†◊ï◊ü ◊î◊§◊†◊ô◊û◊ô ◊ì◊ï◊®◊© ◊™◊ó◊ñ◊ï◊ß◊î ◊¢◊ì◊ô◊†◊î. ◊î◊ì◊ë◊®◊ô◊ù ◊î'◊§◊©◊ï◊ò◊ô◊ù' ‚Äì ◊ú◊¢◊†◊ï◊™ ◊ú◊î◊ï◊ì◊¢◊î, ◊ú◊™◊ó◊ñ◊ß ◊°◊û◊ï◊ú-◊ò◊ï◊ß ‚Äì ◊í◊ï◊ë◊ô◊ù ◊û◊û◊ö ◊û◊° ◊©◊ê◊£ ◊ê◊ó◊ì ◊ú◊ê ◊®◊ï◊ê◊î. ◊ê◊™ ◊†◊¢◊ú◊û◊™ ◊ú◊ê ◊õ◊ô ◊ú◊ê ◊ê◊õ◊§◊™ ◊ú◊ö, ◊ê◊ú◊ê ◊õ◊ô ◊ú◊§◊¢◊û◊ô◊ù, ◊ú◊†◊°◊ó ◊ê◊™ ◊î◊û◊©◊§◊ò ◊î◊û◊ì◊ï◊ô◊ß ◊û◊®◊í◊ô◊© ◊õ◊û◊ï ◊õ◊™◊ô◊ë◊™ ◊°◊û◊ô◊†◊®◊ô◊ï◊ü. ◊î◊§◊¢◊® ◊î◊ñ◊î, ◊ë◊ô◊ü ◊î◊ô◊õ◊ï◊ú◊™ ◊î◊ï◊ï◊®◊ë◊ú◊ô◊™ ◊î◊í◊ë◊ï◊î◊î ◊ú◊ë◊ô◊ü ◊î◊©◊ô◊™◊ï◊ß ◊î◊®◊í◊¢◊ô ◊û◊ï◊ú ◊î◊û◊°◊ö, ◊î◊ï◊ê ◊î◊û◊ß◊ï◊ù ◊©◊ë◊ï ◊ê◊™ ◊¶◊®◊ô◊õ◊î ◊ú◊î◊†◊ô◊ó ◊ú◊¢◊¶◊û◊ö. **◊û◊ï◊™◊® ◊ú◊ê ◊ú◊¢◊†◊ï◊™ ◊û◊ô◊ì. ◊î◊¢◊ï◊ú◊ù ◊ô◊ó◊õ◊î.**"
                ]
            },
            {
                id: "conclusion",
                title: "◊ú◊ó◊ô◊ï◊™ ◊ë◊™◊ï◊ö ◊î◊°◊ï◊í◊®◊ô◊ô◊ù",
                cards: [
                    "◊î◊ß◊©◊® ◊î◊ñ◊î ◊û◊™◊ß◊ô◊ô◊ù ◊ë◊™◊ï◊ö ◊°◊ï◊í◊®◊ô◊ô◊ù. ◊î◊ï◊ê ◊û◊ï◊°◊™◊®, ◊û◊î ◊©◊û◊ï◊†◊¢ ◊û◊û◊†◊ï ◊ú◊ß◊ë◊ú ◊ê◊™ ◊î◊™◊ô◊ß◊ï◊£ ◊î◊ó◊ô◊¶◊ï◊†◊ô ◊©◊õ◊ú ◊õ◊ö ◊û◊®◊í◊ô◊¢ ◊ê◊™ ◊î◊û◊¢◊®◊õ◊™. ◊ê◊™ ◊û◊ó◊ñ◊ô◊ß◊î ◊ê◊™ ◊î◊†◊®◊ò◊ô◊ë ◊î◊ñ◊î ◊ú◊ë◊ì.",
                    "◊ë◊û◊ß◊ï◊ù ◊ú◊†◊°◊ï◊™ '◊ú◊§◊™◊ï◊®' ◊ê◊™ ◊ê◊ô-◊î◊ï◊ì◊ê◊ï◊™, ◊†◊°◊ô ◊ú◊î◊°◊™◊õ◊ú ◊¢◊ú◊ô◊î ◊õ◊¢◊ú ◊û◊¶◊ë ◊¶◊ë◊ô◊®◊î ◊ñ◊û◊†◊ô. ◊û◊ï◊™◊® ◊ú◊ö ◊ú◊î◊†◊ô◊ó ◊ê◊™ ◊î◊õ◊ú◊ô◊ù ◊î◊û◊ó◊ß◊®◊ô◊ô◊ù ◊ë◊¶◊ì. ◊ú◊ê ◊î◊õ◊ú ◊ì◊ï◊®◊© ◊ì◊ß◊ï◊†◊°◊ò◊®◊ï◊ß◊¶◊ô◊î. ◊ú◊§◊¢◊û◊ô◊ù, ◊í◊ù ◊ú◊ê◊ô◊©◊î ◊î◊ó◊ñ◊ß◊î, ◊î◊ô◊§◊î ◊ï◊î◊ó◊õ◊û◊î ◊ë◊ô◊ï◊™◊® ◊ë◊ó◊ì◊®, ◊û◊ï◊™◊® ◊§◊©◊ï◊ò ◊ú◊î◊ô◊ï◊™. **◊ë◊ú◊ô ◊ú◊†◊™◊ó, ◊ë◊ú◊ô ◊ú◊†◊°◊ó, ◊ï◊ë◊ú◊ô ◊ú◊ì◊¢◊™ ◊û◊î ◊ô◊ß◊®◊î ◊ë◊§◊®◊ß ◊î◊ë◊ê.**"
                ]
            }
        ];

        // --- Sparkle Component ---
        const Sparkles = ({ onComplete }) => {
            const particles = Array.from({ length: 12 });
            useEffect(() => {
                const timer = setTimeout(onComplete, 1000);
                return () => clearTimeout(timer);
            }, [onComplete]);

            return (
                <div className="absolute inset-0 pointer-events-none flex items-center justify-center z-50">
                    {particles.map((_, i) => (
                        <motion.div
                            key={i}
                            initial={{ opacity: 1, scale: 0, x: 0, y: 0 }}
                            animate={{
                                opacity: 0,
                                scale: Math.random() * 1.5 + 0.5,
                                x: (Math.random() - 0.5) * 150,
                                y: (Math.random() - 0.5) * 150,
                                rotate: Math.random() * 360
                            }}
                            transition={{ duration: 0.8, ease: "easeOut" }}
                            className="absolute text-xl"
                        >
                            {Math.random() > 0.5 ? 'üíñ' : '‚ú®'}
                        </motion.div>
                    ))}
                </div>
            );
        };

        // --- Typewriter Component ---
        const TypewriterHighlight = ({ text, id, onRegister }) => {
            const [displayedText, setDisplayedText] = useState("");
            const [isComplete, setIsComplete] = useState(false);
            const [showSparkles, setShowSparkles] = useState(false);
            const elementRef = useRef(null);
            const [isVisible, setIsVisible] = useState(false);

            useEffect(() => {
                if (elementRef.current) {
                    onRegister(id, elementRef.current);
                }
            }, [id, onRegister]);

            useEffect(() => {
                const observer = new IntersectionObserver(
                    ([entry]) => {
                        if (entry.isIntersecting && !isVisible) {
                            setIsVisible(true);
                        }
                    },
                    { threshold: 0.5 }
                );
                if (elementRef.current) observer.observe(elementRef.current);
                return () => observer.disconnect();
            }, [isVisible]);

            useEffect(() => {
                if (isVisible && !isComplete) {
                    let index = 0;
                    const interval = setInterval(() => {
                        if (index <= text.length) {
                            setDisplayedText(text.slice(0, index));
                            index++;
                        } else {
                            clearInterval(interval);
                            setIsComplete(true);
                            setShowSparkles(true);
                        }
                    }, 40);
                    return () => clearInterval(interval);
                }
            }, [isVisible, isComplete, text]);

            return (
                <span
                    ref={elementRef}
                    className="relative text-[#9E477B] decoration-clone"
                    style={{
                        display: 'inline',
                        WebkitBoxDecorationBreak: 'clone',
                        boxDecorationBreak: 'clone'
                    }}
                >
                    <span className="bg-[#FF3399]/20 rounded-md transition-all duration-300 py-0.5 px-1">
                        {displayedText}
                        {!isComplete && isVisible && <span className="animate-pulse">|</span>}
                    </span>
                    <span className="opacity-0 w-0 h-0 overflow-hidden absolute">{text}</span>
                    {showSparkles && <Sparkles onComplete={() => setShowSparkles(false)} />}
                </span>
            );
        };

        // --- Text Parser ---
        const ParsedText = ({ content, onRegister, startIndex }) => {
            const parts = content.split(/(\*\*.*?\*\*)/g);
            let highlightCounter = 0;

            return (
                <p className="text-lg leading-relaxed text-[#6A0F49] mb-4">
                    {parts.map((part, index) => {
                        if (part.startsWith('**') && part.endsWith('**')) {
                            const cleanText = part.slice(2, -2);
                            const currentId = startIndex + highlightCounter;
                            highlightCounter++;
                            return (
                                <TypewriterHighlight
                                    key={index}
                                    id={currentId}
                                    text={cleanText}
                                    onRegister={onRegister}
                                />
                            );
                        }
                        return <span key={index}>{part}</span>;
                    })}
                </p>
            );
        };

        // --- Teddy Bear Component ---
        const TeddyBear = ({ scrollState, mood, xPosition, onClick, bubbleText, rednessLevel, scaleLevel }) => {

            // Color Interpolation for Redness (Level 0 to 5)
            const getFurColor = (level) => {
                if (level === 0) return "#E6A8C9";
                const colors = ["#E6A8C9", "#FF99AA", "#FF6688", "#FF3366", "#CC0033", "#8B0000"];
                return colors[Math.min(level, 5)];
            };
            const furColor = getFurColor(rednessLevel);

            // Scale Logic
            const bearScale = 1 + (scaleLevel * 0.1);

            const controls = {
                idle: { y: [0, -3, 0], rotate: [0, 1, 0, -1, 0], transition: { repeat: Infinity, duration: 4, ease: "easeInOut" } },
                scrolling: { y: [0, -10, 0], rotate: [-5, 5], transition: { repeat: Infinity, duration: 0.4 } },
                excited: { scale: [1, 1.2, 1], rotate: [0, -15, 15, 0], transition: { duration: 0.5 } }
            };

            const currentAnimation = mood === 'excited' ? controls.excited : (scrollState ? controls.scrolling : controls.idle);

            // Smart Bubble Positioning Logic
            const isBearOnLeft = xPosition < 50;

            // Close positioning to head
            let bubblePosClass = "";
            let tailPos = {};

            if (isBearOnLeft) {
                // Bear Left -> Bubble on Right of head
                bubblePosClass = "left-[50%] -translate-x-2";
                tailPos = { left: '20px', transform: 'rotate(45deg)' };
            } else {
                // Bear Right -> Bubble on Left of head
                bubblePosClass = "right-[50%] translate-x-2";
                tailPos = { right: '20px', transform: 'rotate(45deg)' };
            }

            return (
                <motion.div
                    className="fixed bottom-4 z-50 select-none w-24 h-24 md:w-32 md:h-32 cursor-pointer touch-manipulation"
                    animate={{
                        left: `${xPosition}%`,
                        scale: bearScale
                    }}
                    transition={{
                        left: { type: "spring", stiffness: 40, damping: 15 },
                        scale: { duration: 0.5 }
                    }}
                    onClick={onClick}
                >
                    <AnimatePresence mode="wait">
                        {bubbleText && (
                            <motion.div
                                key={bubbleText}
                                initial={{ opacity: 0, scale: 0, y: 10 }}
                                animate={{ opacity: 1, scale: 1 + (scaleLevel * 0.1), y: -5 }}
                                exit={{ opacity: 0, scale: 0.5, transition: { duration: 0.2 } }}
                                // Positioning: bottom-[85%] to bring closer to head.
                                className={`absolute bottom-[85%] bg-white border-2 border-[#FF3399] rounded-xl p-2 shadow-lg text-center text-sm font-bold text-[#6A0F49] z-50 pointer-events-none ${bubblePosClass}`}
                                style={{
                                    width: 'max-content',
                                    maxWidth: '120px', // Restrict width to encourage vertical growth
                                    minWidth: '80px',
                                    whiteSpace: 'normal',
                                    lineHeight: '1.2'
                                }}
                            >
                                {bubbleText}
                                <div
                                    className="absolute w-3 h-3 bg-white border-b-2 border-r-2 border-[#FF3399]"
                                    style={{
                                        bottom: '-7px',
                                        ...tailPos,
                                        background: 'white'
                                    }}
                                ></div>
                            </motion.div>
                        )}
                    </AnimatePresence>

                    <motion.div
                        animate={currentAnimation}
                        className="relative w-full h-full drop-shadow-2xl filter"
                        style={{ filter: "drop-shadow(0px 10px 10px rgba(106, 15, 73, 0.3))" }}
                    >
                        <svg viewBox="0 0 200 200" className="w-full h-full">
                            <circle cx="100" cy="140" r="45" fill={furColor} className="transition-colors duration-500" />
                            <circle cx="100" cy="140" r="25" fill="#F8Cce2" opacity="0.6" />

                            <motion.ellipse
                                animate={scrollState ? { ry: [12, 10, 12] } : {}}
                                cx="70" cy="175" rx="15" ry="12" fill={rednessLevel > 2 ? "#8B0000" : "#D689B0"} className="transition-colors duration-500"
                            />
                            <motion.ellipse
                                animate={scrollState ? { ry: [12, 10, 12], transition: {delay: 0.2} } : {}}
                                cx="130" cy="175" rx="15" ry="12" fill={rednessLevel > 2 ? "#8B0000" : "#D689B0"} className="transition-colors duration-500"
                            />

                            <path d="M65 130 Q 80 150 100 145" stroke={rednessLevel > 2 ? "#8B0000" : "#D689B0"} strokeWidth="12" strokeLinecap="round" fill="none" className="transition-colors duration-500" />
                            <path d="M135 130 Q 120 150 100 145" stroke={rednessLevel > 2 ? "#8B0000" : "#D689B0"} strokeWidth="12" strokeLinecap="round" fill="none" className="transition-colors duration-500" />

                            <circle cx="100" cy="85" r="40" fill={furColor} className="transition-colors duration-500" />
                            <circle cx="65" cy="60" r="12" fill={furColor} className="transition-colors duration-500" />
                            <circle cx="65" cy="60" r="6" fill={rednessLevel > 2 ? "#8B0000" : "#D689B0"} className="transition-colors duration-500" />
                            <circle cx="135" cy="60" r="12" fill={furColor} className="transition-colors duration-500" />
                            <circle cx="135" cy="60" r="6" fill={rednessLevel > 2 ? "#8B0000" : "#D689B0"} className="transition-colors duration-500" />

                            <ellipse cx="100" cy="95" rx="14" ry="10" fill="#FFF0F5" />
                            <path d="M96 92 C 94 90, 92 92, 96 96 C 100 92, 98 90, 96 92" fill="#6A0F49" transform="translate(4,0) scale(1.2)" />
                            <circle cx="88" cy="80" r="3" fill="#4A0530" />
                            <circle cx="112" cy="80" r="3" fill="#4A0530" />
                            <circle cx="80" cy="92" r="5" fill="#FF69B4" opacity="0.4" className="animate-pulse" />
                            <circle cx="120" cy="92" r="5" fill="#FF69B4" opacity="0.4" className="animate-pulse" />
                            <text x="92" y="145" fontSize="16">üíñ</text>

                            {mood === 'excited' && (
                                <g>
                                    {[...Array(8)].map((_, i) => (
                                        <circle
                                            key={i}
                                            cx="100"
                                            cy="100"
                                            r={Math.random() * 4 + 2}
                                            fill={["#FF3399", "#FFD700", "#FFF", "#8A2BE2"][i % 4]}
                                            className="animate-ping"
                                            style={{
                                                transformOrigin: 'center',
                                                animationDuration: `${0.5 + Math.random() * 0.5}s`,
                                                transform: `translate(${(Math.random() - 0.5) * 100}px, ${(Math.random() - 0.5) * 100}px)`
                                            }}
                                        />
                                    ))}
                                    <text x="80" y="80" fontSize="20" className="animate-bounce" style={{animationDelay: '0.1s'}}>üíï</text>
                                    <text x="120" y="80" fontSize="20" className="animate-bounce" style={{animationDelay: '0.2s'}}>üíï</text>
                                    <text x="100" y="60" fontSize="20" className="animate-bounce" style={{animationDelay: '0s'}}>üíñ</text>
                                </g>
                            )}
                        </svg>
                    </motion.div>
                </motion.div>
            );
        };

        // --- Main App Component ---
        const App = () => {
            const [bearMood, setBearMood] = useState('idle');
            const [isScrolling, setIsScrolling] = useState(false);
            const [bearX, setBearX] = useState(10);
            const scrollTimeout = useRef(null);

            // --- State Management ---
            const [activeContextId, setActiveContextId] = useState(-1);
            const [nagState, setNagState] = useState({ active: false, level: 0, text: "" });
            const [currentNagIndex, setCurrentNagIndex] = useState(0);

            // Refs
            const highlightRefs = useRef({});
            const nagTimerRef = useRef(null);
            const nagIntervalRef = useRef(null);
            const nagWaitTimerRef = useRef(null);

            // Register highlight elements
            const registerHighlight = useCallback((id, element) => {
                highlightRefs.current[id] = element;
            }, []);

            // --- Nag Logic Implementation ---
            const stopAllNagging = () => {
                clearTimeout(nagTimerRef.current);
                clearInterval(nagIntervalRef.current);
                clearTimeout(nagWaitTimerRef.current);
                setNagState({ active: false, level: 0, text: "" });
            };

            const startNagCycle = () => {
                // If Context active, abort
                if (activeContextId !== -1) return;

                // 1. Wait 3 seconds before showing bubble
                nagTimerRef.current = setTimeout(() => {
                    if (activeContextId !== -1) return;

                    // 2. Show Bubble (Level 1)
                    const text = NAG_BUBBLES[currentNagIndex % NAG_BUBBLES.length];
                    setNagState({ active: true, level: 1, text });

                    // 3. Grow every 3 seconds (Levels 2-5)
                    // Level 1 starts now (T=3s from startNagCycle)
                    // We need to increment level every 3 seconds.
                    let lvl = 1;
                    nagIntervalRef.current = setInterval(() => {
                        if (activeContextId !== -1) {
                            stopAllNagging();
                            return;
                        }

                        lvl++;
                        if (lvl <= 5) {
                            setNagState(prev => ({ ...prev, level: lvl }));
                        } else {
                            // Max level reached (5).
                            // We need to wait 5 seconds before disappearing.
                            clearInterval(nagIntervalRef.current);

                            nagWaitTimerRef.current = setTimeout(() => {
                                if (activeContextId !== -1) return;

                                // Disappear
                                setNagState({ active: false, level: 0, text: "" });

                                // Advance to next message and restart cycle
                                // The change in currentNagIndex triggers the Effect to restart.
                                setCurrentNagIndex(prev => prev + 1);
                            }, 5000);
                        }
                    }, 3000);
                }, 3000);
            };

            // Master Effect for Nagging
            useEffect(() => {
                // Cleanup current timers
                stopAllNagging();

                // If no context is active, start the cycle
                if (activeContextId === -1) {
                    startNagCycle();
                }

                return () => stopAllNagging();
            }, [activeContextId, currentNagIndex]);


            // --- Effects ---

            // ** MODIFICATION: Auto-Hide Context Bubble after 4 seconds **
            useEffect(() => {
                if (activeContextId !== -1) {
                    const timer = setTimeout(() => {
                        setActiveContextId(-1);
                    }, 4000);
                    return () => clearTimeout(timer);
                }
            }, [activeContextId]);

            // 1. Context Detection (Scroll)
            useEffect(() => {
                const handleScroll = () => {
                    if (!isScrolling) setIsScrolling(true);
                    clearTimeout(scrollTimeout.current);

                    // Bear Movement
                    scrollTimeout.current = setTimeout(() => {
                        setIsScrolling(false);
                        setBearX(5 + Math.random() * 75);
                    }, 500);

                    // --- Scroll Logic for Context ---
                    // "Goldilocks Zone" ~ 60% down the screen
                    const triggerY = window.innerHeight * 0.6;

                    let bestCandidateId = -1;
                    let minDistance = Infinity;

                    Object.keys(highlightRefs.current).forEach(key => {
                        const el = highlightRefs.current[key];
                        if (el) {
                            const rect = el.getBoundingClientRect();
                            const elementCenter = rect.top + (rect.height / 2);

                            // Distance from trigger point
                            const dist = Math.abs(elementCenter - triggerY);

                            // Only consider if reasonably on screen
                            if (rect.top < window.innerHeight && rect.bottom > 0) {
                                if (dist < minDistance) {
                                    minDistance = dist;
                                    bestCandidateId = parseInt(key);
                                }
                            }
                        }
                    });

                    // Update active context
                    if (bestCandidateId !== -1 && bestCandidateId !== activeContextId) {
                        setActiveContextId(bestCandidateId);
                        // Nagging is handled by the Effect listening to activeContextId
                    }
                };

                window.addEventListener('scroll', handleScroll);
                return () => window.removeEventListener('scroll', handleScroll);
            }, [isScrolling, activeContextId]);


            // --- Handlers ---
            const handleBearClick = () => {
                setBearMood('excited');

                // Stop Nagging and Clear Context
                // We want to make it disappear ("Poof").
                stopAllNagging();

                // If it was Nagging, we want to advance to next message eventually (or just restart).
                // If it was Context, we want to clear it.
                // Resetting activeContextId to -1 (if it was context) works.
                // Resetting nagState works.

                const wasContext = activeContextId !== -1;
                if (wasContext) {
                    setActiveContextId(-1);
                } else {
                    // It was nagging (or idle). If nagging, advance index to restart cycle with next message?
                    // User click implies interaction, so we can reset to idle.
                    // To ensure cycle restarts with next message if it was nagging:
                    setCurrentNagIndex(prev => prev + 1);
                }

                // Bear reset after animation
                setTimeout(() => {
                    setBearMood('idle');
                }, 1500);
            };

            // --- Render Logic ---
            let bubbleText = null;
            let currentRedness = 0;
            let currentScale = 0;

            // PRIORITY: Context > Nag
            if (activeContextId !== -1 && CONTEXT_BUBBLES[activeContextId]) {
                bubbleText = CONTEXT_BUBBLES[activeContextId];
                currentRedness = 0; // Context always resets bear
                currentScale = 0;   // Context always resets size
            } else if (nagState.active) {
                bubbleText = nagState.text;
                currentRedness = nagState.level;
                currentScale = nagState.level;
            }

            let globalHighlightIndex = 0;

            return (
                <div className="min-h-screen pb-32 relative">
                    <div className="fixed inset-0 pointer-events-none overflow-hidden">
                        <div className="absolute top-10 left-10 text-6xl opacity-20 floating-bg">‚òÅÔ∏è</div>
                        <div className="absolute top-40 right-20 text-4xl opacity-20 floating-bg" style={{animationDelay: '1s'}}>üíñ</div>
                        <div className="absolute bottom-40 left-20 text-5xl opacity-20 floating-bg" style={{animationDelay: '2s'}}>‚ú®</div>
                        <div className="absolute bottom-10 right-10 text-6xl opacity-20 floating-bg" style={{animationDelay: '3s'}}>üç≠</div>
                        <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-[800px] h-[800px] bg-white opacity-10 rounded-full blur-3xl"></div>
                    </div>

                    <header className="pt-12 pb-8 px-4 text-center relative z-10">
                        <motion.div
                            initial={{ y: -50, opacity: 0 }}
                            animate={{ y: 0, opacity: 1 }}
                            transition={{ type: "spring", stiffness: 100 }}
                        >
                            <h1 className="text-4xl md:text-6xl text-[#6A0F49] drop-shadow-sm mb-2">
                                The Strategic Heart
                            </h1>
                            <div className="inline-block bg-white/40 backdrop-blur-md rounded-full px-4 py-1 border border-white/50">
                                <span className="text-sm font-bold tracking-widest text-[#FF3399] uppercase">Dossier: Kitsch Edition</span>
                            </div>
                        </motion.div>
                    </header>

                    <main className="max-w-2xl mx-auto px-4 space-y-12 relative z-10">
                        {contentData.map((section, index) => {
                            const currentStartIndex = globalHighlightIndex;
                            const matches = (JSON.stringify(section.cards).match(/\*\*(.*?)\*\*/g) || []).length;
                            globalHighlightIndex += matches;

                            return (
                                <motion.section
                                    key={section.id}
                                    initial={{ opacity: 0, y: 50 }}
                                    whileInView={{ opacity: 1, y: 0 }}
                                    viewport={{ once: true, margin: "-50px" }}
                                    transition={{ duration: 0.6, delay: index * 0.1 }}
                                    className="glass-card rounded-[3rem] p-6 md:p-8"
                                >
                                    <div className="mb-6 flex items-center gap-3">
                                        <div className="w-3 h-3 rounded-full bg-[#FF3399] animate-pulse"></div>
                                        <h2 className="text-2xl md:text-3xl text-[#6A0F49]">{section.title}</h2>
                                    </div>

                                    <div className="space-y-6">
                                        {section.cards.map((cardText, cIndex) => (
                                            <div
                                                key={cIndex}
                                                className="bg-white/40 rounded-2xl p-6 border border-white/60 hover:bg-white/50 transition-colors duration-300"
                                            >
                                                <ParsedText
                                                    content={cardText}
                                                    onRegister={registerHighlight}
                                                    startIndex={currentStartIndex}
                                                />
                                            </div>
                                        ))}
                                    </div>
                                </motion.section>
                            );
                        })}
                    </main>

                    <footer className="mt-20 text-center text-[#6A0F49]/60 pb-8 text-sm relative z-10">
                        <p>¬© 2026 Lovecore Systems Inc. All feelings preserved in sugar.</p>
                        <p className="text-xs mt-2 opacity-50">System Status: Heartbeat Stable</p>
                    </footer>

                    <TeddyBear
                        scrollState={isScrolling}
                        mood={bearMood}
                        xPosition={bearX}
                        onClick={handleBearClick}
                        bubbleText={bubbleText}
                        rednessLevel={currentRedness}
                        scaleLevel={currentScale}
                    />
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
